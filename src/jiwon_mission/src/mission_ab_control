// PD 제어

#include <ros/ros.h>
#include <std_msgs/Float64.h>
#include <std_msgs/Int32.h>
#include <geometry_msgs/Polygon.h>
#include <string>
#include <cmath>

// -------------------- 유틸 --------------------
inline double clamp(double x, double lo, double hi)
{
  return (x < lo) ? lo : (x > hi) ? hi : x;
}

// -------------------- 전역 상태 --------------------
// 토픽 이름
static std::string g_motor_topic;
static std::string g_servo_topic;

// 서보 스케일
static double g_servo_center = 0.5;
static double g_servo_min    = 0.0;
static double g_servo_max    = 1.0;
static double g_steer_sign   = -1.0;   // 조향 방향 보정

// 모터 명령 (dir != 0 일 때 항상 이 값으로 전진)
static double g_forward_motor_cmd = 1000.0;

// 회전/정렬 관련 파라미터
static double g_entry_duration_sec = 2.0;   // 첫 진입 회전 시간
static double g_align_duration_sec = 0.5;   // 반대 방향으로 평행 맞추는 시간
static double g_turn_steer_cmd     = 1.0;   // 진입/정렬 때 조향 크기 (-1~+1)

// 차선 추종 관련 파라미터
static double g_lane_img_width_px    = 640.0; // lane 이미지 가로 픽셀
static double g_lane_kp              = 0.004; // P gain
static double g_lane_kd              = 0.001; // D gain
static double g_target_x_ratio_left  = 0.30;  // 왼쪽 차선 목표 위치 (화면 가로 30%) -> 튜닝 필요
static double g_target_x_ratio_right = 0.70;  // 오른쪽 차선 목표 위치 (화면 가로 70%) -> 튜닝 필요

// 퍼블리셔
static ros::Publisher g_pub_motor;
static ros::Publisher g_pub_servo;

// 내부 타이머 상태
static bool      g_turn_running     = false;
static ros::Time g_turn_start_time;
static ros::Time g_last_step_time;

// 현재 진행 중인 방향 (이전 dir 기억용)
static int g_current_turn_dir = 0; // -1: LEFT, +1: RIGHT

// 차선 중심 좌표 (Polygon) 최근 값
static geometry_msgs::Polygon g_left_centers;
static geometry_msgs::Polygon g_right_centers;
static bool g_has_left_centers  = false;
static bool g_has_right_centers = false;

// PD용 이전 에러 (픽셀) & 플래그
static double g_prev_err_left_px   = 0.0;
static bool   g_has_prev_left_err  = false;
static double g_prev_err_right_px  = 0.0;
static bool   g_has_prev_right_err = false;

// -------------------- 차선 중심 콜백 --------------------
void leftCentersCallback(const geometry_msgs::Polygon::ConstPtr& msg)
{
  g_left_centers = *msg;
  g_has_left_centers = !msg->points.empty();
}

void rightCentersCallback(const geometry_msgs::Polygon::ConstPtr& msg)
{
  g_right_centers = *msg;
  g_has_right_centers = !msg->points.empty();
}

// -------------------- lane 기반 PD 조향 계산 --------------------
double computeLaneSteerPD(const geometry_msgs::Polygon& poly,
                          double img_width_px,
                          double target_x_ratio,
                          double Kp,
                          double Kd,
                          double dt,
                          double& prev_err_px,
                          bool&   has_prev_err)
{
  if (poly.points.empty() || img_width_px <= 0.0 || dt <= 0.0)
  {
    has_prev_err = false;
    prev_err_px  = 0.0;
    return 0.0;
  }

  // 1) x 좌표 평균 (차선 중심)
  double sum_x = 0.0;
  for (size_t i = 0; i < poly.points.size(); ++i)
    sum_x += poly.points[i].x;
  double mean_x = sum_x / static_cast<double>(poly.points.size());

  // 2) 에러 (픽셀)
  double target_x = target_x_ratio * img_width_px;
  double err_px   = mean_x - target_x;  // >0 이면 차선이 목표보다 오른쪽

  // 3) D term 계산
  double d_err = 0.0;
  if (has_prev_err && dt > 1e-4)
    d_err = (err_px - prev_err_px) / dt;

  prev_err_px   = err_px;
  has_prev_err  = true;

  // 4) PD 제어: 에러가 오른쪽(+err)이면 왼쪽으로 꺾도록 부호 반전
  double steer_cmd = -(Kp * err_px + Kd * d_err);

  // 5) -1 ~ +1 제한
  steer_cmd = clamp(steer_cmd, -1.0, 1.0);

  return steer_cmd;
}

// -------------------- 초기화 함수 --------------------
void mission_AB_init(ros::NodeHandle& nh, ros::NodeHandle& pnh)
{
  ROS_INFO("[AB_turn] mission_AB_init()");

  // --- 파라미터 로드 ---
  pnh.param<std::string>("motor_topic", g_motor_topic,
                         std::string("/commands/motor/speed"));
  pnh.param<std::string>("servo_topic", g_servo_topic,
                         std::string("/commands/servo/position"));

  // 서보 스케일
  pnh.param<double>("servo_center", g_servo_center, 0.5);
  pnh.param<double>("servo_min",    g_servo_min,    0.0);
  pnh.param<double>("servo_max",    g_servo_max,    1.0);
  pnh.param<double>("steer_sign",   g_steer_sign,  -1.0);

  // 모터
  pnh.param<double>("forward_motor_cmd", g_forward_motor_cmd, 1000.0);

  // 회전/정렬 파라미터
  pnh.param<double>("entry_duration_sec", g_entry_duration_sec, 2.0);
  pnh.param<double>("align_duration_sec", g_align_duration_sec, 0.5);
  pnh.param<double>("turn_steer_cmd",     g_turn_steer_cmd,     1.0);

  // 차선 추종 파라미터
  pnh.param<double>("lane_img_width_px",    g_lane_img_width_px,    640.0);
  pnh.param<double>("lane_kp",              g_lane_kp,              0.004);
  pnh.param<double>("lane_kd",              g_lane_kd,              0.001);
  pnh.param<double>("target_x_ratio_left",  g_target_x_ratio_left,  0.30);
  pnh.param<double>("target_x_ratio_right", g_target_x_ratio_right, 0.70);

  ROS_INFO("[AB_turn] publish motor='%s', servo='%s'",
           ros::names::resolve(g_motor_topic).c_str(),
           ros::names::resolve(g_servo_topic).c_str());
  ROS_INFO("[AB_turn] entry=%.2fs, align=%.2fs, turn_steer=%.2f, motor=%.1f",
           g_entry_duration_sec, g_align_duration_sec,
           g_turn_steer_cmd, g_forward_motor_cmd);
  ROS_INFO("[AB_turn] lane: imgW=%.1f, Kp=%.5f, Kd=%.5f, target(L,R)=(%.2f, %.2f)",
           g_lane_img_width_px, g_lane_kp, g_lane_kd,
           g_target_x_ratio_left, g_target_x_ratio_right);

  // --- Pub ---
  g_pub_motor = nh.advertise<std_msgs::Float64>(g_motor_topic, 10);
  g_pub_servo = nh.advertise<std_msgs::Float64>(g_servo_topic, 10);

  g_turn_running     = false;
  g_turn_start_time  = ros::Time(0);
  g_last_step_time   = ros::Time(0);
  g_current_turn_dir = 0;

  g_has_prev_left_err  = false;
  g_has_prev_right_err = false;

  ROS_INFO("[AB_turn] mission_AB_init done");
}

// -------------------- 한 스텝 실행 --------------------
// dir: -1 = LEFT, +1 = RIGHT, 0 = NONE
void mission_AB_step(int dir)
{
  ros::Time now = ros::Time::now();

  double dt = 0.0;
  if (!g_last_step_time.isZero())
  {
    dt = (now - g_last_step_time).toSec();

    double gap = dt;
    if (gap > 0.5)
    {
      g_turn_running     = false;
      g_turn_start_time  = ros::Time(0);
      g_current_turn_dir = 0;

      g_has_prev_left_err  = false;
      g_has_prev_right_err = false;

      ROS_INFO("[AB_turn] re-entered mission -> reset timer & PD state");
    }
  }
  g_last_step_time = now;

  // dir이 0이면: 회전 미션이 아니라는 뜻 → 여기서는 정지
  if (dir == 0)
  {
    double steer_cmd = 0.0;

    // 조향 변환
    double steer_norm = clamp(steer_cmd, -1.0, 1.0);
    steer_norm *= (-g_steer_sign);

    double servo_range = std::min(g_servo_center - g_servo_min,
                                  g_servo_max - g_servo_center);
    double servo_hw = g_servo_center + steer_norm * servo_range;
    servo_hw = clamp(servo_hw, g_servo_min, g_servo_max);

    // 모터: 완전 정지
    double motor_cmd = 0.0;

    std_msgs::Float64 motor_msg;
    std_msgs::Float64 servo_msg;
    motor_msg.data = motor_cmd;
    servo_msg.data = servo_hw;

    g_pub_motor.publish(motor_msg);
    g_pub_servo.publish(servo_msg);

    ROS_INFO_THROTTLE(1.0,
      "[AB_turn] dir=0 -> stop (motor=%.1f)", motor_cmd);
    return;
  }

  // dir != 0 인 경우: 새로운 방향이면 타이머 & PD 상태 리셋
  if (!g_turn_running || (dir != g_current_turn_dir))
  {
    g_turn_running     = true;
    g_turn_start_time  = now;
    g_current_turn_dir = dir;

    g_has_prev_left_err  = false;
    g_has_prev_right_err = false;

    ROS_INFO("[AB_turn] START: dir=%d, entry=%.2fs, align=%.2fs",
             g_current_turn_dir, g_entry_duration_sec, g_align_duration_sec);
  }

  double elapsed = (now - g_turn_start_time).toSec();

  double steer_cmd = 0.0;

  const double entry_end = g_entry_duration_sec;
  const double align_end = g_entry_duration_sec + g_align_duration_sec;

  if (elapsed < entry_end)
  {
    // 1단계: 진입 - dir 방향으로 강하게 꺾기
    steer_cmd = g_current_turn_dir * g_turn_steer_cmd;

    ROS_INFO_THROTTLE(0.5,
      "[AB_turn] ENTRY t=%.2f/%.2f dir=%d steer=%.2f",
      elapsed, entry_end, g_current_turn_dir, steer_cmd);
  }
  else if (elapsed < align_end)
  {
    // 2단계: 평행 정렬 - 반대 방향으로 잠깐
    steer_cmd = -g_current_turn_dir * g_turn_steer_cmd;

    ROS_INFO_THROTTLE(0.5,
      "[AB_turn] ALIGN t=%.2f/%.2f dir=%d steer=%.2f",
      elapsed, align_end, g_current_turn_dir, steer_cmd);
  }
  else
  {
    // 3단계: 갈림길 내 한쪽 차선만 보고 추종 (PD)
    if (dt <= 0.0)
      dt = 1.0 / 50.0; // fallback (50Hz 기준)

    if (g_current_turn_dir < 0)
    {
      // LEFT: 왼쪽 차선 추종
      if (g_has_left_centers)
      {
        steer_cmd = computeLaneSteerPD(
                      g_left_centers,
                      g_lane_img_width_px,
                      g_target_x_ratio_left,
                      g_lane_kp,
                      g_lane_kd,
                      dt,
                      g_prev_err_left_px,
                      g_has_prev_left_err);
      }
      else
      {
        steer_cmd = 0.0;
        g_has_prev_left_err = false;
      }
    }
    else
    {
      // RIGHT: 오른쪽 차선 추종
      if (g_has_right_centers)
      {
        steer_cmd = computeLaneSteerPD(
                      g_right_centers,
                      g_lane_img_width_px,
                      g_target_x_ratio_right,
                      g_lane_kp,
                      g_lane_kd,
                      dt,
                      g_prev_err_right_px,
                      g_has_prev_right_err);
      }
      else
      {
        steer_cmd = 0.0;
        g_has_prev_right_err = false;
      }
    }

    ROS_INFO_THROTTLE(0.5,
      "[AB_turn] LANE-FOLLOW t=%.2f dir=%d steer=%.3f (motor=%.1f, dt=%.3f)",
      elapsed, g_current_turn_dir, steer_cmd, g_forward_motor_cmd, dt);
  }

  // ---- 1) 조향 변환: -1~+1 -> 서보 0~1 ----
  double steer_norm = clamp(steer_cmd, -1.0, 1.0);
  steer_norm *= (-g_steer_sign);

  double servo_range = std::min(g_servo_center - g_servo_min,
                                g_servo_max - g_servo_center);
  double servo_hw = g_servo_center + steer_norm * servo_range;
  servo_hw = clamp(servo_hw, g_servo_min, g_servo_max);

  // ---- 2) 모터: dir != 0 인 동안은 항상 g_forward_motor_cmd ----
  double motor_cmd = g_forward_motor_cmd;

  // ---- 3) Publish ----
  std_msgs::Float64 motor_msg;
  std_msgs::Float64 servo_msg;
  motor_msg.data = motor_cmd;
  servo_msg.data = servo_hw;

  g_pub_motor.publish(motor_msg);
  g_pub_servo.publish(servo_msg);

  ROS_INFO_THROTTLE(0.5,
    "[AB_turn][loop] t=%.2f dir=%d steer_cmd=%.3f servo=%.3f motor=%.1f",
    elapsed, g_current_turn_dir, steer_cmd, servo_hw, motor_cmd);
}

// -------------------- dir 명령 수신용 전역 --------------------
static int g_latest_dir = 0;   // -1 = LEFT, 0 = NONE, +1 = RIGHT

void dirCallback(const std_msgs::Int32::ConstPtr& msg)
{
  int d = msg->data;
  if (d < 0)      g_latest_dir = -1;
  else if (d > 0) g_latest_dir = +1;
  else            g_latest_dir = 0;
}

// -------------------- main --------------------
int main(int argc, char** argv)
{
  ros::init(argc, argv, "mission_ab_turn_node");
  ros::NodeHandle nh;
  ros::NodeHandle pnh("~");

  // 미션 초기화 (파라미터 로드 + pub 준비)
  mission_AB_init(nh, pnh);

  // dir 토픽 이름 파라미터
  std::string dir_topic;
  pnh.param<std::string>("dir_topic", dir_topic,
                         std::string("/mission/ab_turn_dir"));

  ros::Subscriber sub_dir =
      nh.subscribe(dir_topic, 10, dirCallback);

  // 차선 중심 구독
  ros::Subscriber sub_left_centers =
      nh.subscribe("/perception/left_window_centers_px",
                   1, leftCentersCallback);
  ros::Subscriber sub_right_centers =
      nh.subscribe("/perception/right_window_centers_px",
                   1, rightCentersCallback);

  ros::Rate rate(50.0);   // 50 Hz 루프

  ROS_INFO("[AB_turn] main loop started. Subscribed dir='%s'",
           ros::names::resolve(dir_topic).c_str());

  while (ros::ok())
  {
    ros::spinOnce();

    // 최신 dir 값으로 한 스텝 실행
    mission_AB_step(g_latest_dir);

    rate.sleep();
  }

  return 0;
}
